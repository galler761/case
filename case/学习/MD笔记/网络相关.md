### (1)讲讲网络OSI七层模型，TCP/IP和HTTP分别位于哪一层
<img src='img/networkModel.png' />
<img src='img/networkModel1.png' />

### (2)常见HTTP状态码有哪些
##### 2xx 开头（请求成功）
200 OK：客户端发送给服务器的请求被正常处理并返回

##### 3xx 开头（重定向）
301 Moved Permanently：永久重定向，请求的网页已永久移动到新位置。 服务器返回此响应时，会自动将请求者转到新位置
302 Moved Permanently：临时重定向，请求的网页已临时移动到新位置。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
304 Not Modified：未修改，自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容

##### 4xx 开头（客户端错误）
400 Bad Request：错误请求，服务器不理解请求的语法，常见于客户端传参错误
401 Unauthorized：未授权，表示发送的请求需要有通过 HTTP 认证的认证信息，常见于客户端未登录
403 Forbidden：禁止，服务器拒绝请求，常见于客户端权限不足
404 Not Found：未找到，服务器找不到对应资源

##### 5xx 开头（服务端错误）
500 Inter Server Error：服务器内部错误，服务器遇到错误，无法完成请求
501 Not Implemented：尚未实施，服务器不具备完成请求的功能
502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
503 service unavailable：服务不可用，服务器目前无法使用（处于超载或停机维护状态）。通常是暂时状态。

### (3)GET请求和POST请求有何区别
+ 标准答案：
1. GET请求参数放在URL上，POST请求参数放在请求体里
2. GET请求参数长度有限制，POST请求参数长度可以非常大
3. POST请求相较于GET请求安全一点点，因为GET请求的参数在URL上，且有历史记录
4. GET请求能缓存，POST不能
+ 更进一步：
+ 其实HTTP协议并没有要求GET/POST请求参数必须放在URL上或请求体里，也没有规定GET请求的长度，目前对URL的长度限制，是各家浏览器设置的限制。GET和POST的根本区别在于：GET请求是幂等性的，而POST请求不是
+ 由于GET请求是幂等的，在网络不好的环境中，GET请求可能会重复尝试，造成重复操作数据的风险，因此，GET请求用于无副作用的操作(如搜索)，新增/删除等操作适合用POST

### (4)HTTP的请求报文由哪几部分组成
+ 一个HTTP请求报文由请求行（request line）、请求头（header）、空行和请求数据4个部分组成
<img src='img/requestMessage.png' />

### (5)HTTP常见请求/响应头及其含义
##### 通用头（请求头和响应头都有的首部）
<img src='img/HTTP1.png'/>

##### 请求头
<img src='img/HTTP2.png'/>

##### 响应头
<img src='img/HTTP3.png'/>

##### 实体头（针对请求报文和响应报文的实体部分使用首部）
<img src='img/HTTP4.png'/>

### (6)HTTP/1.0和HTTP/1.1有什么区别
1. 长连接： HTTP/1.1支持长连接和请求的流水线，在一个TCP连接上可以传送多个HTTP请求，避免了因为多次建立TCP连接的时间消耗和延时
2. 缓存处理： HTTP/1.1引入Entity tag，If-Unmodified-Since, If-Match, If-None-Match等新的请求头来控制缓存，详见浏览器缓存小节
3. 带宽优化及网络连接的使用： HTTP1.1则在请求头引入了range头域，支持断点续传功能
4. Host头处理： 在HTTP/1.0中认为每台服务器都有唯一的IP地址，但随着虚拟主机技术的发展，多个主机共享一个IP地址愈发普遍，HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会400错误

### (7) 介绍一下HTTP/2.0新特性
1. 多路复用： 即多个请求都通过一个TCP连接并发地完成
2. 服务端推送： 服务端能够主动把资源推送给客户端
3. 新的二进制格式： HTTP/2采用二进制格式传输数据，相比于HTTP/1.1的文本格式，二进制格式具有更好的解析性和拓展性
4. header压缩： HTTP/2压缩消息头，减少了传输数据的大小

### (8)说说HTTP/2.0多路复用基本原理以及解决的问题
+ HTTP/2解决的问题，就是HTTP/1.1存在的问题：
1. TCP慢启动： TCP连接建立后，会经历一个先慢后快的发送过程，就像汽车启动一般，如果我们的网页文件(HTML/JS/CSS/icon)都经过一次慢启动，对性能是不小的损耗。另外慢启动是TCP为了减少网络拥塞的一种策略，我们是没有办法改变的。
2. 多条TCP连接竞争带宽： 如果同时建立多条TCP连接，当带宽不足时就会竞争带宽，影响关键资源的下载。
3. HTTP/1.1队头阻塞： 尽管HTTP/1.1长链接可以通过一个TCP连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束前，其他请求只能处于阻塞状态。
为了解决以上几个问题，HTTP/2一个域名只使用一个TCP⻓连接来传输数据，而且请求直接是并行的、非阻塞的，这就是多路复用
实现原理： HTTP/2引入了一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求ID的帧，这些帧在传输完成后根据ID组合成对应的数据。

### (9)说说HTTP/3.0
+ 尽管HTTP/2解决了很多1.1的问题，但HTTP/2仍然存在一些缺陷，这些缺陷并不是来自于HTTP/2协议本身，而是来源于底层的TCP协议，我们知道TCP链接是可靠的连接，如果出现了丢包，那么整个连接都要等待重传，HTTP/1.1可以同时使用6个TCP连接，一个阻塞另外五个还能工作，但HTTP/2只有一个TCP连接，阻塞的问题便被放大了。
+ 由于TCP协议已经被广泛使用，我们很难直接修改TCP协议，基于此，HTTP/3选择了一个折衷的方法——UDP协议，HTTP/2在UDP的基础上实现多路复用、0-RTT、TLS加密、流量控制、丢包重传等功能。
### (10)HTTP和HTTPS有何区别
1. HTTPS使用443端口，而HTTP使用80
2. HTTPS需要申请证书
3. HTTP是超文本传输协议，是明文传输；HTTPS是经过SSL加密的协议，传输更安全
4. HTTPS比HTTP慢，因为HTTPS除了TCP握手的三个包，还要加上SSL握手的九个包

### (11)HTTPS是如何进行加密的
##### 对称加密
+ 客户端和服务器公用一个密匙用来对消息加解密，这种方式称为对称加密。客户端和服务器约定好一个加密的密匙。客户端在发消息前用该密匙对消息加密，发送给服务器后，服务器再用该密匙进行解密拿到消息。 
<img src='img/encryption1.png'/>

+ 这种方式一定程度上保证了数据的安全性，但密钥一旦泄露(密钥在传输过程中被截获)，传输内容就会暴露，因此我们要寻找一种安全传递密钥的方法。
##### 非对称加密
+ 采用非对称加密时，客户端和服务端均拥有一个公钥和私钥，公钥加密的内容只有对应的私钥能解密。私钥自己留着，公钥发给对方。这样在发送消息前，先用对方的公钥对消息进行加密，收到后再用自己的私钥进行解密。这样攻击者只拿到传输过程中的公钥也无法破解传输的内容 
<img src='img/encryption2.png'/>

+ 尽管非对称加密解决了由于密钥被获取而导致传输内容泄露的问题，但中间人仍然可以用篡改公钥的方式来获取或篡改传输内容，而且非对称加密的性能比对称加密的性能差了不少 
<img src='img/encryption3.jpeg'/>

##### 第三方认证
+ 上面这种方法的弱点在于，客户端不知道公钥是由服务端返回，还是中间人返回的，因此我们再引入一个第三方认证的环节：即第三方使用私钥加密我们自己的公钥，浏览器已经内置一些权威第三方认证机构的公钥，浏览器会使用第三方的公钥来解开第三方私钥加密过的我们自己的公钥，从而获取公钥，如果能成功解密，就说明获取到的自己的公钥是正确的
+ 但第三方认证也未能完全解决问题，第三方认证是面向所有人的，中间人也能申请证书，如果中间人使用自己的证书掉包原证书，客户端还是无法确认公钥的真伪
<img src='img/encryption4.jpeg'/>

##### 数字签名
+ 为了让客户端能够验证公钥的来源，我们给公钥加上一个数字签名，这个数字签名是由企业、网站等各种信息和公钥经过单向hash而来，一旦构成数字签名的信息发生变化，hash值就会改变，这就构成了公钥来源的唯一标识。
+ 具体来说，服务端本地生成一对密钥，然后拿着公钥以及企业、网站等各种信息到CA(第三方认证中心)去申请数字证书，CA会通过一种单向hash算法(比如MD5)，生成一串摘要，这串摘要就是这堆信息的唯一标识，然后CA还会使用自己的私钥对摘要进行加密，连同我们自己服务器的公钥一同发送给我我们。
+ 浏览器拿到数字签名后，会使用浏览器本地内置的CA公钥解开数字证书并验证，从而拿到正确的公钥。由于非对称加密性能低下，拿到公钥以后，客户端会随机生成一个对称密钥，使用这个公钥加密并发送给服务端，服务端用自己的私钥解开对称密钥，此后的加密连接就通过这个对称密钥进行对称加密。
+ 综上所述，HTTPS在验证阶段使用非对称加密+第三方认证+数字签名获取正确的公钥，获取到正确的公钥后以对称加密的方式通信
<img src='img/encryption5.png'/>
