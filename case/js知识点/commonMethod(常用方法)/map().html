<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // arr.map 方法是最有用和经常使用的方法之一。语法
        // let result = arr.map(function(item, index, array) {
        //     返回新值而不是当前元素
        // })
        // 它对数组中每个元素调用函数并返回符合结果的数组。
        // 例如，在这里我们将每个元素转换为它的字符串长度
        let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length)
        console.log(lengths); // 5,7,6
    </script>
    <script>
        // Map 是一个键值对的集合，很像 Object。但主要的区别是，Map 允许所有数据类型作为键。
        // 主要的方法包括：
        // new Map()– 创建 map。
        // map.set(key, value)– 根据键（ key） 存储值（ value）。
        // map.get(key)– 根据键返回值， 如果 map 中该键不存在， 返回 undefined。
        // map.has(key)– 如果键存在， 返回 true， 否则返回 false。
        // map.delete(key)– 移除该键的值。
        // map.clear()– 清空 map
        // map.size– 返回当前元素个数。

        // 例子：
        let map = new Map();
        map.set('1', 'str1'); // 字符串作为 key
        map.set(1, 'num1'); // 数字作为 key
        map.set(true, 'bool1'); // 布尔值作为 key
        // 还记得普通对象 Object 吗？它将会把所有的键转化为字符串类型
        // 但是 Map 将会保留键的类型，所以下面这两个是不同的：
        console.log(map.get(1)); // 'num1'
        console.log(map.get('1')); // 'str1'
        console.log(map.size); // 3
        // 正如我们所见，不像普通对象，键并没有被转化为字符串。任何类型的键都是可以的
    </script>
    <script>
        // Map 可以使用对象作为键。
        let john = {
            name: "John"
        };
        let visitsCountMap = new Map(); // 存下每个用户的来访次数
        visitsCountMap.set(john, 123); // john 是 map 的键
        console.log(visitsCountMap.get(john)); // 123
        // 可以将对象用作键是 Map 最显著最重要的特点。对于字符串类型的键，Object 可以适用，
        // 但是对于上面这个例子，把 Map 替换成普通的对象 Object 就很困难了。

        // 改造：在 Map 类型存在之前的时候，人们将唯一标识加入对象来达成 Map 的功能：
        // 我们添加了一个 id 字段
        let john1 = {
            name: "John",
            id: 1
        };
        let visitsCounts = {};
        visitsCounts[john1.id] = 123; // 现在，通过 id 来保存值
        console.log(visitsCounts[john1.id]); // 123

        // 每次 map.set 的调用将会返回 map 自身，所以可以链式调用
        map.set('1', 'str1')
            .set(1, 'num1')
            .set(true, 'bool1');
    </script>

    <script>
        // 将 Object 转化为 Map
        // 创建 Map 时，我们可以像这样传递一个数组（或其他可迭代对象）给构造函数：
        // [key, value] 键值对数组
        let map1 = new Map([
            ['1', 'str1'],
            [1, 'num1'],
            [true, 'bool1']
        ]);
        // 有一个内建方法 Object.entries(obj)， 它可以返回一个对象的键值对数组， 格式就和上面一样。
        // 所以我们可以用一个对象来初始化一个 map， 就像这样：
        let map2 = new Map(Object.entries({
            name: "John",
            age: 30
        }));
        console.log(map2);
        // 这里，Object.entries 返回了键值对数组：[ ["name","John"], ["age", 30] ]。这正是 Map 需要的。
    </script>

    <script>
        // 遍历 Map
        // 有三种方法可以循环遍历 map：
        // map.keys()– 返回键的迭代器，
        // map.values()– 返回值的迭代器，
        // map.entries()– 返回[key, value] 迭代器入口，for..of 循环会默认使用它。
        let recipeMap = new Map([
            ['cucumber', 500],
            ['tomatoes', 350],
            ['onion', 50]
        ]);
        // 迭代键（vegetables）
        for (let vegetable of recipeMap.keys()) {
            console.log(vegetable); // cucumber, tomatoes, onion
        }
        // 迭代值（amounts）
        for (let amount of recipeMap.values()) {
            console.log(amount); // 500, 350, 50
        }
        // 迭代键值对 [key, value]
        for (let entry of recipeMap) { // 和 recipeMap.entries() 一样
            console.log(entry); // cucumber,500（等等）
        }
        // 注意：普通 Object 不同，迭代器的迭代顺序和值被插入的顺序一致，Map 会保留这个顺序。
    </script>

    <script>
        // Map 有一个内建的 forEach 方法，和 Array 很像：
        recipeMap.forEach((value, key, map) => {
            console.log(`${key}: ${value}`); // cucumber: 500 等等
        });
    </script>
</body>

</html>