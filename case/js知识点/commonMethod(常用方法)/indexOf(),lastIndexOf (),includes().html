<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>查询数组</title>
</head>

<body>
    <script>
        // 在字符串中查找子字符串
        // 第一个方法是 str.indexOf(substr, pos)。
        // 从给定位置 pos 开始，在 str 中查找 substr，如果没有找到，则返回 -1，否则返回匹配成功的位置。
        let str = 'Widget with id';
        alert(str.indexOf('Widget')); // 0，因为 'Widget' 一开始就被找到
        alert(str.indexOf('widget')); // -1，没有找到，检索是大小写敏感的
        alert(str.indexOf("id")); // 1，"id" 在位置 1 处（……idget 和 id）
        // 可选的第二个参数允许我们从给定的起始位置开始检索
        // 例如，"id" 第一次出现的位置是 1。查询下一个存在位置时，我们从 2 开始检索：
        let str = 'Widget with id';
        alert(str.indexOf('id', 2)) // 12

        // 我们对所有存在位置都感兴趣，可以在一个循环中使用 indexOf。每一次新的调用都发生在上一匹配位置之后
        let str = 'As sly as a fox, as strong as an ox';
        let target = 'as'; // 让我们查看一下
        let pos = 0;
        while (true) {
            let foundPos = str.indexOf(target, pos);
            if (foundPos == -1) break;
            alert(`Found at ${foundPos}`);
            pos = foundPos + 1; // 继续从下一个位置查找
        }
        // 相同的算法可以简写
        let str = "As sly as a fox, as strong as an ox";
        let target = "as";
        let pos = -1;
        while ((pos = str.indexOf(target, pos + 1)) != -1) {
            alert(pos);
        }

        // 因为 str.indexOf("Widget") 返回 0（意思是它在起始位置查找匹配）。是的，但是 if 认为 0 应该是 false
        let str = "Widget with id";
        if (str.indexOf("Widget") != -1) {
            alert("We found it"); // 现在运行了！
        }
        // 简写 indexOf 检查
        let str = "Widget";
        if (~str.indexOf("Widget")) {
            alert('Found it!'); // 正常运行
        }
    </script>
    <script>
        // 在数组中查询某些内容的方法
        // arr.indexOf、arr.lastIndexOf 和 arr.includes 方法与字符串操作具有相同的语法，只不过这里是对数组元素而不是字符进行操作：
        // arr.indexOf(item, from) 从索引 from 查询 item，如果找到返回索引，否则返回 -1。
        // arr.lastIndexOf(item, from) — 和上面相同，只是从尾部开始查询。
        // arr.includes(item, from) — 从索引 from 查询 item，如果找到则返回 true。
        // 例如：注意，这些方法使用 === 比较。所以如果我们查询 false，会精确到是 false 而不是零
        let arr = [1, 0, false];
        console.log(arr.indexOf(0)); // 1
        console.log(arr.indexOf(false)); // 2
        console.log(arr.indexOf(null)); // -1
        console.log(arr.includes(1)); // true
        // 如果我们想检查是否包含需要的元素，并且不想知道确切的索引，那么 arr.includes 是首选
        // includes 的一个非常小的差别是它能正确处理NaN，而不像 indexOf/lastIndexOf：
        const arr2 = [NaN];
        console.log(arr2.indexOf(NaN)); // -1 (should be 0, but === equality doesn't work for NaN)
        console.log(arr2.includes(NaN)); // true (correct)
    </script>
</body>

</html>